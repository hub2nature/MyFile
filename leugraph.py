# -*- coding: utf-8 -*-
"""LeuGraph.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1McpF3oZtacu_THBYbLwpT6EfvggWC__9
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/DTI_prediction/LeuGraph

# Commented out IPython magic to ensure Python compatibility.
# %cd GADTI/

!pip install dgl

import numpy as np

def loda_data():
    network_path = 'data/'

    drug_drug = np.loadtxt(network_path + 'mat_drug_drug.txt')
    true_drug = 708
    drug_chemical = np.loadtxt(network_path + 'Similarity_Matrix_Drugs.txt')
    drug_chemical = drug_chemical[:true_drug, :true_drug]
    drug_disease = np.loadtxt(network_path + 'mat_drug_disease.txt')
    drug_sideeffect = np.loadtxt(network_path + 'mat_drug_se.txt')

    protein_protein = np.loadtxt(network_path + 'mat_protein_protein.txt')
    protein_sequence = np.loadtxt(network_path + 'Similarity_Matrix_Proteins.txt')
    protein_disease = np.loadtxt(network_path + 'mat_protein_disease.txt')

    num_drug = len(drug_drug)
    num_protein = len(protein_protein)

    # Removed the self-loop
    drug_chemical = drug_chemical - np.identity(num_drug)
    protein_sequence = protein_sequence / 100.
    protein_sequence = protein_sequence - np.identity(num_protein)

    drug_protein = np.loadtxt(network_path + 'mat_drug_protein.txt')


    drug_protein = np.loadtxt(network_path + 'mat_drug_protein_homo_protein_drug.txt')

    print("Load data finished.")
    print("Load data finished.")
    print("First 5 rows of each matrix:")
    print("Drug-Drug Interactions:\n", drug_drug[:5])
    print("Drug-Chemical Similarities:\n", drug_chemical[:5])
    print("Drug-Disease Associations:\n", drug_disease[:5])
    print("Drug-Side Effects:\n", drug_sideeffect[:5])
    print("Protein-Protein Interactions:\n", protein_protein[:5])
    print("Protein Sequence Similarities:\n", protein_sequence[:5])
    print("Protein-Disease Associations:\n", protein_disease[:5])
    print("Drug-Protein Interactions:\n", drug_protein[:5])

    return drug_drug, drug_chemical, drug_disease, drug_sideeffect, protein_protein, protein_sequence, \
           protein_disease, drug_protein
drug_d, drug_ch, drug_di, drug_side, protein_p, protein_seq, protein_di, dti_original = loda_data()

import dgl

!pip install --upgrade pandas dgl pyarrow

import dgl
def ConstructGraph(drug_drug, drug_chemical, drug_disease, drug_sideeffect, protein_protein, protein_sequence,
                   protein_disease, drug_protein):
    num_drug = len(drug_drug)
    num_protein = len(protein_protein)
    num_disease = len(drug_disease.T)
    num_sideeffect = len(drug_sideeffect.T)

    list_drug = []
    for i in range(num_drug):
        list_drug.append((i, i))

    list_protein = []
    for i in range(num_protein):
        list_protein.append((i, i))

    list_disease = []
    for i in range(num_disease):
        list_disease.append((i, i))

    list_sideeffect = []
    for i in range(num_sideeffect):
        list_sideeffect.append((i, i))

    list_DDI = []
    for row in range(num_drug):
        for col in range(num_drug):
            if drug_drug[row, col] > 0:
                list_DDI.append((row, col))

    list_PPI = []
    for row in range(num_protein):
        for col in range(num_protein):
            if protein_protein[row, col] > 0:
                list_PPI.append((row, col))

    list_drug_protein = []
    list_protein_drug = []
    for row in range(num_drug):
        for col in range(num_protein):
            if drug_protein[row, col] > 0:
                list_drug_protein.append((row, col))
                list_protein_drug.append((col, row))

    list_drug_sideeffect = []
    list_sideeffect_drug = []
    for row in range(num_drug):
        for col in range(num_sideeffect):
            if drug_sideeffect[row, col] > 0:
                list_drug_sideeffect.append((row, col))
                list_sideeffect_drug.append((col, row))

    list_drug_disease = []
    list_disease_drug = []
    for row in range(num_drug):
        for col in range(num_disease):
            if drug_disease[row, col] > 0:
                list_drug_disease.append((row, col))
                list_disease_drug.append((col, row))

    list_protein_disease = []
    list_disease_protein = []
    for row in range(num_protein):
        for col in range(num_disease):
            if protein_disease[row, col] > 0:
                list_protein_disease.append((row, col))
                list_disease_protein.append((col, row))

    g_HIN = dgl.heterograph({('disease', 'disease_disease virtual', 'disease'): list_disease,
                             ('drug', 'drug_drug virtual', 'drug'): list_drug,
                             ('protein', 'protein_protein virtual', 'protein'): list_protein,
                             ('sideeffect', 'sideeffect_sideeffect virtual', 'sideeffect'): list_sideeffect,
                             ('drug', 'drug_drug interaction', 'drug'): list_DDI, \
                             ('protein', 'protein_protein interaction', 'protein'): list_PPI, \
                             ('drug', 'drug_protein interaction', 'protein'): list_drug_protein, \
                             ('protein', 'protein_drug interaction', 'drug'): list_protein_drug, \
                             ('drug', 'drug_sideeffect association', 'sideeffect'): list_drug_sideeffect, \
                             ('sideeffect', 'sideeffect_drug association', 'drug'): list_sideeffect_drug, \
                             ('drug', 'drug_disease association', 'disease'): list_drug_disease, \
                             ('disease', 'disease_drug association', 'drug'): list_disease_drug, \
                             ('protein', 'protein_disease association', 'disease'): list_protein_disease, \
                             ('disease', 'disease_protein association', 'protein'): list_disease_protein})

    g = g_HIN.edge_type_subgraph(['drug_drug interaction', 'protein_protein interaction',
                                  'drug_protein interaction', 'protein_drug interaction',
                                  'drug_sideeffect association', 'sideeffect_drug association',
                                  'drug_disease association', 'disease_drug association',
                                  'protein_disease association', 'disease_protein association'
                                  ])


    return g

g = ConstructGraph(drug_d, drug_ch, drug_di, drug_side, protein_p, protein_seq, protein_di, dti_original)

class HGTConv(MessagePassing):
    def __init__(self, in_dim, out_dim, num_types, num_relations, n_heads, dropout=0.2, use_norm=True, use_RTE=True):
        super(HGTConv, self).__init__(aggr='add')  # "Add" aggregation.
        self.in_dim = in_dim
        self.out_dim = out_dim
        self.num_types = num_types
        self.num_relations = num_relations
        self.n_heads = n_heads
        self.d_k = out_dim // n_heads
        self.sqrt_dk = math.sqrt(self.d_k)
        self.use_norm = use_norm
        self.use_RTE = use_RTE

        # Define the layers for transformation
        self.k_linears = nn.ModuleList([nn.Linear(in_dim, out_dim) for _ in range(num_types)])
        self.q_linears = nn.ModuleList([nn.Linear(in_dim, out_dim) for _ in range(num_types)])
        self.v_linears = nn.ModuleList([nn.Linear(in_dim, out_dim) for _ in range(num_types)])
        self.a_linears = nn.ModuleList([nn.Linear(out_dim, out_dim) for _ in range(num_types)])
        self.norms = nn.ModuleList([nn.LayerNorm(out_dim) for _ in range(num_types)] if use_norm else [])

        # Parameters for relations
        self.relation_pri = nn.Parameter(torch.ones(num_relations, n_heads))
        self.relation_att = nn.Parameter(torch.Tensor(num_relations, n_heads, self.d_k, self.d_k))
        self.relation_msg = nn.Parameter(torch.Tensor(num_relations, n_heads, self.d_k, self.d_k))
        self.skip = nn.Parameter(torch.ones(num_types))
        self.drop = nn.Dropout(dropout)

        if self.use_RTE:
            self.emb = RelTemporalEncoding(in_dim)

        self.reset_parameters()

    def reset_parameters(self):
        # Initialize parameters
        for lin in self.k_linears + self.q_linears + self.v_linears + self.a_linears:
            nn.init.xavier_uniform_(lin.weight, gain=nn.init.calculate_gain('relu'))
            nn.init.constant_(lin.bias, 0)

        for mat in [self.relation_att, self.relation_msg]:
            nn.init.xavier_uniform_(mat)

    def forward(self, node_inp, node_type, edge_index, edge_type, edge_time):
        return self.propagate(edge_index, size=(node_inp.size(0), node_inp.size(0)), node_inp=node_inp,
                              node_type=node_type, edge_type=edge_type, edge_time=edge_time)

    def message(self, node_inp_j, node_type_j, edge_index, edge_type, node_inp_i, node_type_i, edge_time):
        # Message function
        pass

    def update(self, aggr_out):
        # Update function
        pass

    def __repr__(self):
        return '{}(in_dim={}, out_dim={}, num_types={}, num_relations={}, n_heads={})'.format(
            self.__class__.__name__, self.in_dim, self.out_dim, self.num_types, self.num_relations, self.n_heads)

# Example to initialize node features and types, edge index, and edge types
node_features = torch.randn((num_nodes, feature_size))  # Random features
node_types = torch.randint(0, num_types, (num_nodes,))  # Random types for nodes
edge_index = torch.randint(0, num_nodes, (2, num_edges))  # Random connections
edge_types = torch.randint(0, num_relations, (num_edges,))  # Random types for edges

class HGTNetwork(nn.Module):
    def __init__(self, in_dim, out_dim, num_types, num_relations, n_heads):
        super(HGTNetwork, self).__init__()
        self.hgt_layer = HGTConv(in_dim, out_dim, num_types, num_relations, n_heads)

    def forward(self, x, node_type, edge_index, edge_type, edge_time):
        x = self.hgt_layer(x, node_type, edge_index, edge_type, edge_time)
        return x

# Initialize the model
model = HGTNetwork(feature_size, output_size, num_types, num_relations, n_heads)

optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
criterion = nn.CrossEntropyLoss()  # Modify as per your task

for epoch in range(epochs):
    model.train()
    optimizer.zero_grad()
    out = model(node_features, node_types, edge_index, edge_types, None)  # edge_time if available
    loss = criterion(out, labels)  # Assuming labels are defined
    loss.backward()
    optimizer.step()
    print('Epoch:', epoch, 'Loss:', loss.item())